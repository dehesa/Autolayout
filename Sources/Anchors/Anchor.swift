#if os(iOS) || os(tvOS)
import UIKit
#elseif os(macOS)
import Cocoa
#else
#error("OS not supported")
#endif

/// Concrete types conforming to this protocol represent a layout anchor used in Autolayout.
public protocol LayoutAnchor {
    /// The type of constant associated with the given layout anchor.
    associatedtype Constant: AnchorConstant
    /// The constraint type generated by the receiving anchor.
    associatedtype Constraint
    
    /// Generates the constraint/s of of the equality relation between the receiving and passed anchors.
    func constraint(equalTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
    /// Generates the constraint/s of the "greater than" inequality relation between the receiving and passed anchors.
    func constraint(greaterThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
    /// Generates the constraint/s of the "less than" inequality relation between the receiving and passed anchors.
    func constraint(lessThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
}

 // MARK: - Single Anchors

extension NSLayoutDimension: LayoutAnchor {
    public typealias Constant = CGFloat
    public typealias Constraint = NSLayoutConstraint
    
    public func constraint(equalTo anchor: NSLayoutDimension, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        let result = self.constraint(equalTo: anchor, multiplier: multiplier ?? 0, constant: constant ?? 0)
        result.priority = priority
        return result
    }
    
    public func constraint(greaterThanOrEqualTo anchor: NSLayoutDimension, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        let result = self.constraint(greaterThanOrEqualTo: anchor, multiplier: multiplier ?? 0, constant: constant ?? 0)
        result.priority = priority
        return result
    }
    
    public func constraint(lessThanOrEqualTo anchor: NSLayoutDimension, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        let result = self.constraint(lessThanOrEqualTo: anchor, multiplier: multiplier ?? 0, constant: constant ?? 0)
        result.priority = priority
        return result
    }
}

extension NSLayoutXAxisAnchor: LayoutAnchor {
    public typealias Constant = CGFloat
    public typealias Constraint = NSLayoutConstraint
    
    public func constraint(equalTo anchor: NSLayoutXAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(equalTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
    
    public func constraint(greaterThanOrEqualTo anchor: NSLayoutXAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(greaterThanOrEqualTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
    
    public func constraint(lessThanOrEqualTo anchor: NSLayoutXAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(lessThanOrEqualTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
}

extension NSLayoutYAxisAnchor: LayoutAnchor {
    public typealias Constant = CGFloat
    public typealias Constraint = NSLayoutConstraint
    
    public func constraint(equalTo anchor: NSLayoutYAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(equalTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
    
    public func constraint(greaterThanOrEqualTo anchor: NSLayoutYAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(greaterThanOrEqualTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
    
    public func constraint(lessThanOrEqualTo anchor: NSLayoutYAxisAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGFloat?) -> NSLayoutConstraint {
        return self.constraint(lessThanOrEqualTo: anchor, constant: constant ?? 0).duplicate(withMultiplier: multiplier, priority: priority)
    }
}

// MARK: - Two Anchors

/// A layout anchor representing the width and height of the object generating this instance.
public struct SizeAnchor: LayoutAnchor {
    public typealias Constant = CGSize
    public typealias Constraint = NSLayoutConstraint.Size
    /// The actual width and height anchors.
    internal let widthAnchor: NSLayoutDimension, heightAnchor: NSLayoutDimension

    internal init(width: NSLayoutDimension, height: NSLayoutDimension) {
        (self.widthAnchor, self.heightAnchor) = (width, height)
    }
    
    public func constraint(equalTo anchor: SizeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGSize?) -> NSLayoutConstraint.Size {
        return .make(with: (self.widthAnchor.constraint(equalTo:  anchor.widthAnchor,  priority, multiplier: multiplier, constant: constant?.width),
                            self.heightAnchor.constraint(equalTo: anchor.heightAnchor, priority, multiplier: multiplier, constant: constant?.height)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: SizeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGSize?) -> NSLayoutConstraint.Size {
        return .make(with: (self.widthAnchor.constraint(greaterThanOrEqualTo:  anchor.widthAnchor,  priority, multiplier: multiplier, constant: constant?.width),
                            self.heightAnchor.constraint(greaterThanOrEqualTo: anchor.heightAnchor, priority, multiplier: multiplier, constant: constant?.height)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: SizeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGSize?) -> NSLayoutConstraint.Size {
        return .make(with: (self.widthAnchor.constraint(lessThanOrEqualTo:  anchor.widthAnchor,  priority, multiplier: multiplier, constant: constant?.width),
                            self.heightAnchor.constraint(lessThanOrEqualTo: anchor.heightAnchor, priority, multiplier: multiplier, constant: constant?.height)))
    }
}

public struct CenterAnchor: LayoutAnchor {
    public typealias Constant = CGPoint
    public typealias Constraint = NSLayoutConstraint.Center

    internal let x: NSLayoutXAxisAnchor, y: NSLayoutYAxisAnchor

    internal init(x: NSLayoutXAxisAnchor, y: NSLayoutYAxisAnchor) {
        (self.x, self.y) = (x, y)
    }
    
    public func constraint(equalTo anchor: CenterAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGPoint?) -> NSLayoutConstraint.Center {
        return .make(with: (self.x.constraint(equalTo:  anchor.x,  priority, multiplier: multiplier, constant: constant?.x),
                     self.y.constraint(equalTo: anchor.y, priority, multiplier: multiplier, constant: constant?.y)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: CenterAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGPoint?) -> NSLayoutConstraint.Center {
        return .make(with: (self.x.constraint(greaterThanOrEqualTo:  anchor.x,  priority, multiplier: multiplier, constant: constant?.x),
                     self.y.constraint(greaterThanOrEqualTo: anchor.y, priority, multiplier: multiplier, constant: constant?.y)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: CenterAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: CGPoint?) -> NSLayoutConstraint.Center {
        return .make(with: (self.x.constraint(lessThanOrEqualTo:  anchor.x,  priority, multiplier: multiplier, constant: constant?.x),
                     self.y.constraint(lessThanOrEqualTo: anchor.y, priority, multiplier: multiplier, constant: constant?.y)))
    }
}

public struct VerticalAnchor: LayoutAnchor {
    public typealias Constant = VerticalInsets
    public typealias Constraint = NSLayoutConstraint.Vertical
    
    internal let top: NSLayoutYAxisAnchor, bottom: NSLayoutYAxisAnchor
    
    internal init(top: NSLayoutYAxisAnchor, bottom: NSLayoutYAxisAnchor) {
        (self.top, self.bottom) = (top, bottom)
    }
    
    public func constraint(equalTo anchor: VerticalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: VerticalInsets?) -> NSLayoutConstraint.Vertical {
        return .make(with: (self.top.constraint(equalTo:  anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.bottom.constraint(equalTo: anchor.bottom, priority, multiplier: multiplier, constant: constant?.bottom)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: VerticalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: VerticalInsets?) -> NSLayoutConstraint.Vertical {
        return .make(with: (self.top.constraint(greaterThanOrEqualTo:  anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.bottom.constraint(greaterThanOrEqualTo: anchor.bottom, priority, multiplier: multiplier, constant: constant?.bottom)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: VerticalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: VerticalInsets?) -> NSLayoutConstraint.Vertical {
        return .make(with: (self.top.constraint(lessThanOrEqualTo:  anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.bottom.constraint(lessThanOrEqualTo: anchor.bottom, priority, multiplier: multiplier, constant: constant?.bottom)))
    }
}

public struct HorizontalAnchor: LayoutAnchor {
    public typealias Constant = HorizontalInsets
    public typealias Constraint = NSLayoutConstraint.Horizontal

    let left: NSLayoutXAxisAnchor, right: NSLayoutXAxisAnchor

    init(left: NSLayoutXAxisAnchor, right: NSLayoutXAxisAnchor) {
        (self.left, self.right) = (left, right)
    }
    
    public func constraint(equalTo anchor: HorizontalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: HorizontalInsets?) -> NSLayoutConstraint.Horizontal {
        return .make(with: (self.left.constraint(equalTo:  anchor.left,  priority, multiplier: multiplier, constant: constant?.left),
                     self.right.constraint(equalTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: HorizontalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: HorizontalInsets?) -> NSLayoutConstraint.Horizontal {
        return .make(with: (self.left.constraint(greaterThanOrEqualTo:  anchor.left,  priority, multiplier: multiplier, constant: constant?.left),
                     self.right.constraint(greaterThanOrEqualTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: HorizontalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: HorizontalInsets?) -> NSLayoutConstraint.Horizontal {
        return .make(with: (self.left.constraint(lessThanOrEqualTo:  anchor.left,  priority, multiplier: multiplier, constant: constant?.left),
                     self.right.constraint(lessThanOrEqualTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
}

public struct DirectionalAnchor: LayoutAnchor {
    public typealias Constant = DirectionalInsets
    public typealias Constraint = NSLayoutConstraint.Directional

    let leading: NSLayoutXAxisAnchor, trailing: NSLayoutXAxisAnchor

    init(leading: NSLayoutXAxisAnchor, trailing: NSLayoutXAxisAnchor) {
        (self.leading, self.trailing) = (leading, trailing)
    }
    
    public func constraint(equalTo anchor: DirectionalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalInsets?) -> NSLayoutConstraint.Directional {
        return .make(with: (self.leading.constraint(equalTo:  anchor.leading,  priority, multiplier: multiplier, constant: constant?.leading),
                     self.trailing.constraint(equalTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: DirectionalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalInsets?) -> NSLayoutConstraint.Directional {
        return .make(with: (self.leading.constraint(greaterThanOrEqualTo:  anchor.leading,  priority, multiplier: multiplier, constant: constant?.leading),
                     self.trailing.constraint(greaterThanOrEqualTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: DirectionalAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalInsets?) -> NSLayoutConstraint.Directional {
        return .make(with: (self.leading.constraint(lessThanOrEqualTo:  anchor.leading,  priority, multiplier: multiplier, constant: constant?.leading),
                     self.trailing.constraint(lessThanOrEqualTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
}

// MARK: - Four Anchors

public struct EdgeAnchor: LayoutAnchor {
    public typealias Constant = EdgeInsets
    public typealias Constraint = NSLayoutConstraint.Edges

    let top: NSLayoutYAxisAnchor, bottom: NSLayoutYAxisAnchor
    let left: NSLayoutXAxisAnchor, right: NSLayoutXAxisAnchor

    init(top: NSLayoutYAxisAnchor, left: NSLayoutXAxisAnchor, bottom: NSLayoutYAxisAnchor, right: NSLayoutXAxisAnchor) {
        (self.top, self.bottom) = (top, bottom)
        (self.left, self.right) = (left, right)
    }
    
    public func constraint(equalTo anchor: EdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: EdgeInsets?) -> NSLayoutConstraint.Edges {
        return .make(with: (self.top.constraint(equalTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.left.constraint(equalTo: anchor.left, priority, multiplier: multiplier, constant: constant?.left),
                     self.bottom.constraint(equalTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.right.constraint(equalTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: EdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: EdgeInsets?) -> NSLayoutConstraint.Edges {
        return .make(with: (self.top.constraint(greaterThanOrEqualTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.left.constraint(greaterThanOrEqualTo: anchor.left, priority, multiplier: multiplier, constant: constant?.left),
                     self.bottom.constraint(greaterThanOrEqualTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.right.constraint(greaterThanOrEqualTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: EdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: EdgeInsets?) -> NSLayoutConstraint.Edges {
        return .make(with: (self.top.constraint(lessThanOrEqualTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.left.constraint(lessThanOrEqualTo: anchor.left, priority, multiplier: multiplier, constant: constant?.left),
                     self.bottom.constraint(lessThanOrEqualTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.right.constraint(lessThanOrEqualTo: anchor.right, priority, multiplier: multiplier, constant: constant?.right)))
    }
}

public struct DirectionalEdgeAnchor: LayoutAnchor {
    public typealias Constant = DirectionalEdgeInsets
    public typealias Constraint = NSLayoutConstraint.DirectionalEdges

    let top: NSLayoutYAxisAnchor, bottom: NSLayoutYAxisAnchor
    let leading: NSLayoutXAxisAnchor, trailing: NSLayoutXAxisAnchor

    init(top: NSLayoutYAxisAnchor, leading: NSLayoutXAxisAnchor, bottom: NSLayoutYAxisAnchor, trailing: NSLayoutXAxisAnchor) {
        (self.top, self.bottom) = (top, bottom)
        (self.leading, self.trailing) = (leading, trailing)
    }
    
    public func constraint(equalTo anchor: DirectionalEdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalEdgeInsets?) -> NSLayoutConstraint.DirectionalEdges {
        return .make(with: (self.top.constraint(equalTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.leading.constraint(equalTo: anchor.leading, priority, multiplier: multiplier, constant: constant?.leading),
                     self.bottom.constraint(equalTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.trailing.constraint(equalTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: DirectionalEdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalEdgeInsets?) -> NSLayoutConstraint.DirectionalEdges {
        return .make(with: (self.top.constraint(greaterThanOrEqualTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.leading.constraint(greaterThanOrEqualTo: anchor.leading, priority, multiplier: multiplier, constant: constant?.leading),
                     self.bottom.constraint(greaterThanOrEqualTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.trailing.constraint(greaterThanOrEqualTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
    
    public func constraint(lessThanOrEqualTo anchor: DirectionalEdgeAnchor, _ priority: LayoutPriority, multiplier: CGFloat?, constant: DirectionalEdgeInsets?) -> NSLayoutConstraint.DirectionalEdges {
        return .make(with: (self.top.constraint(lessThanOrEqualTo: anchor.top,  priority, multiplier: multiplier, constant: constant?.top),
                     self.leading.constraint(lessThanOrEqualTo: anchor.leading, priority, multiplier: multiplier, constant: constant?.leading),
                     self.bottom.constraint(lessThanOrEqualTo: anchor.bottom,  priority, multiplier: multiplier, constant: constant?.bottom),
                     self.trailing.constraint(lessThanOrEqualTo: anchor.trailing, priority, multiplier: multiplier, constant: constant?.trailing)))
    }
}
