#if os(iOS) || os(tvOS)
import UIKit
#elseif os(macOS)
import Cocoa
#else
#error("OS not supported")
#endif

/// Concrete types conforming to this protocol represent a layout anchor used in Autolayout.
public protocol LayoutAnchor {
    /// The type of constant associated with the given layout anchor.
    associatedtype Constant: LayoutConstant
    /// The constraint type generated by the receiving anchor.
    associatedtype Constraint: LayoutConstraint
    
    /// Generates the constraint/s of of the equality relation between the receiving and passed anchors.
    func constraint(equalTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
    /// Generates the constraint/s of the "greater than" inequality relation between the receiving and passed anchors.
    func constraint(greaterThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
    /// Generates the constraint/s of the "less than" inequality relation between the receiving and passed anchors.
    func constraint(lessThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint
}

/// An anchor defined in UIKit.
internal protocol LayoutAnchorSingle: LayoutAnchor where Self.Constant == CGFloat, Self.Constraint == NSLayoutConstraint {
    
}

/// An anchor internally grouping two single anchors (e.g. `SizeAnchor`, `CenterAnchor`, etc.).
internal protocol LayoutAnchorPair: LayoutAnchor where Self.Constant: LayoutConstantPair, Self.Constraint: LayoutConstraintGroup, Self.Constraint.Constraints == (NSLayoutConstraint, NSLayoutConstraint) {
    /// The anchor type for the first single anchor.
    associatedtype AnchorA: LayoutAnchorSingle
    /// The anchor type for the second single anchor.
    associatedtype AnchorB: LayoutAnchorSingle
    /// Designated initializer for the anchor group.
    init(_ anchorA: AnchorA, _ anchorB: AnchorB)
    /// Returns all stored single anchors.
    var all: (AnchorA, AnchorB) { get }
}

extension LayoutAnchorPair {
    public func constraint(equalTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(equalTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(equalTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(greaterThanOrEqualTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(greaterThanOrEqualTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint))
    }
    
    public func constraint(lessThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(lessThanOrEqualTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(lessThanOrEqualTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint))
    }
}

/// An anchor internally grouping four single anchors (e.g. `EdgeAnchor`).
internal protocol LayoutAnchorQuartet: LayoutAnchor where Self.Constant: LayoutConstantQuartet, Self.Constraint: LayoutConstraintGroup, Self.Constraint.Constraints == (NSLayoutConstraint, NSLayoutConstraint, NSLayoutConstraint, NSLayoutConstraint) {
    /// The anchor type for the first single anchor.
    associatedtype AnchorA: LayoutAnchorSingle
    /// The anchor type for the second single anchor.
    associatedtype AnchorB: LayoutAnchorSingle
    /// The anchor type for the third single anchor.
    associatedtype AnchorC: LayoutAnchorSingle
    /// The anchor type for the fourth single anchor.
    associatedtype AnchorD: LayoutAnchorSingle
    /// Designated initializer for the anchor group.
    init(_ anchorA: AnchorA, _ anchorB: AnchorB, _ anchorC: AnchorC, _ anchorD: AnchorD)
    /// Returns all stored single anchors.
    var all: (AnchorA, AnchorB, AnchorC, AnchorD) { get }
}

extension LayoutAnchorQuartet {
    public func constraint(equalTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(equalTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(equalTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        let thirdConstraint = lhs.2.constraint(equalTo: rhs.2, priority, multiplier: multiplier, constant: constant?.third)
        let fourthConstraint = lhs.3.constraint(equalTo: rhs.3, priority, multiplier: multiplier, constant: constant?.fourth)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint, thirdConstraint, fourthConstraint))
    }
    
    public func constraint(greaterThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(greaterThanOrEqualTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(greaterThanOrEqualTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        let thirdConstraint = lhs.2.constraint(greaterThanOrEqualTo: rhs.2, priority, multiplier: multiplier, constant: constant?.third)
        let fourthConstraint = lhs.3.constraint(greaterThanOrEqualTo: rhs.3, priority, multiplier: multiplier, constant: constant?.fourth)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint, thirdConstraint, fourthConstraint))
    }
    
    public func constraint(lessThanOrEqualTo anchor: Self, _ priority: LayoutPriority, multiplier: CGFloat?, constant: Self.Constant?) -> Self.Constraint {
        let (lhs, rhs) = (self.all, anchor.all)
        let firstConstraint = lhs.0.constraint(lessThanOrEqualTo: rhs.0, priority, multiplier: multiplier, constant: constant?.first)
        let secondConstraint = lhs.1.constraint(lessThanOrEqualTo: rhs.1, priority, multiplier: multiplier, constant: constant?.second)
        let thirdConstraint = lhs.2.constraint(lessThanOrEqualTo: rhs.2, priority, multiplier: multiplier, constant: constant?.third)
        let fourthConstraint = lhs.3.constraint(lessThanOrEqualTo: rhs.3, priority, multiplier: multiplier, constant: constant?.fourth)
        return Self.Constraint.make(with: (firstConstraint, secondConstraint, thirdConstraint, fourthConstraint))
    }
}
